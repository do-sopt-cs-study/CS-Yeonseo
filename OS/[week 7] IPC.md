#📚IPC(Inter Process Communication): 프로세스 간 통신 방법

## 🌟 IPC란?

### 1. IPC의 정의

- 프로세스들 사이에서 서로 데이터를 주고 받는 행위 또는 그에 대한 방법
- 즉, 프로세스 간의 통신
- 독립된 실행 개체인 프로세스 간 통신을 위해서는 커널이 제공하는 IPC 모델 방식을 사용해야 한다.
  - 복습) 커널 ?
    - 운영체제의 핵심적인 부분으로, 다른 모든 부분에 여러 기본적인 서비스를 제공해준다.
    - 운영체제 자체도 소프트웨어이기 때문에 메모리에 올라가야 사용할 수 있다. 하지만 메모리 공간의 제약으로 운영체제 중 항상 필요한 부분만을 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라 한다. (보통은 운영체제라고 하면 커널을 말하게 된다.)

### 2. IPC의 필요성

- 프로세스는 독립된 메모리 영역을 가지고 실행되므로 다른 프로세스에 영향을 받지 않는다.
  - _cf. 스레드는 프로세스 안에서 자원을 공유하므로 서로 영향을 받는다._
  ⇒ 따라서 이러한 독립적인 구조를 가진 프로세스 간 통신을 가능하게 하기 위해서는 IPC 통신이 필요하다.
- 모듈화 : 기능을 분리해야 하는 경우
  - ex. 특정 task를 여러 개의 sub task로 나누어 더 빠르게 수행해야 하는 경우
- 편리성 : 사용자가 여러 작업을 동시에 수행해야 할 때
  - ex. 동시에 많은 task를 한 번에 처리해야 하는 경우
- 연산 속도 향상
- 정보 공유

---

## 🌟 IPC 기법의 종류

### 1. `메시지 전달 (Message Passing) 방식`

![Untitled (14)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/ff8b6e5e-13c1-457a-bd65-c487a109dbf4)

> 커널이 제공하는 API를 이용해서 커널 공간을 통해 통신한다.
>
> - 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메시지 형태로 정보를 Send/Receive 하는 방법
> - 커널을 경유하여 메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링한다.
> - 프로세스 간 메모리 공유 없이 동작이 가능하다.

**장점**

- 커널에서 데이터의 주고 받는 것을 컨트롤할 수 있어 별도의 동기화 로직이 필요하지 않다.

**단점**

- 커널을 통해서 데이터를 주고 받기 때문에 Shared Memory 모델보다 느리다.

### 2. `공유 메모리 (Shared Memory) 방식`

![Untitled (15)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/32ddeaad-ae85-46d4-9d8f-ec2fd9328958)

> 프로세스끼리 특정 공통의 메모리 영역을 공유하며 상호간 통신하는 방법이다.
>
> - 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해 준다.
> - 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.
> - 공유 메모리가 설정되면, 그 이후의 통신은 커널의 관여 없이 진행이 가능하다.
> - 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해 통신을 수행한다. (Read and Write)

**장점:**

- 커널의 관여 없이 메모리를 직접 사용하여 빠르게 IPC 통신이 가능하다.
- 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.

**단점:**

- 메시지 전달 방식이 아니기에 데이터를 읽어야 하는 시점을 알 수 없고, 별도의 동기화 기술이 필요하다.
- 동시에 같은 메모리 위치를 접근하는 경우가 발생할 수 있기 때문에 공유 메모리에 접근할 프로세스 간의 Lock 메커니즘이 필요하다.
- 커널 설정에 종속적이기 때문에 사용하기 전 커널에서 사용하고 있는 공유 메모리 사이즈를 확인해야 한다.

### 3. `익명 Pipe`

> 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다.
>
> - **한쪽 방향으로만 통신이 가능한 반이중 통신**이라고도 부른다.
> - 따라서 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 한다.

**장점 :**

- 매우 간단하게 사용할 수 있다.
- 따라서 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다.

**단점 :**

- 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 된다.

### 4. `Named Pipe(FIFO)`

> 익명 파이프의 확장된 상태로 **부모 프로세스와 무관한 다른 프로세스도 통신이 가능한 형**식
>
> - 통신을 위해 이름있는 파일을 사용한다.
> - Named 파이프 역시 읽기/쓰기 동시에 불가능하다.
>   → 따라서 전이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능
> - cf. 익명 파이프 vs Named 파이프
>   - 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (ex.부모-자식 프로세스 간 통신)
>   - Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다.

### 5. `메모리 맵`

> 메모리 맵은 공유 메모리처럼 메모리를 공유해주며,  열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다.
>
> - 즉 공유 매개체가 파일+메모리이다.
> - 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.

### 6. `소켓`

![Untitled (16)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/6f53fd74-0189-4899-8aff-aff08c05d871)

> 네트워크 소켓 통신을 통해 데이터를 공유한다.
>
> - 소켓은 본래 네트워크 통신을 위한 기술이지만, 컴퓨터 안에서 두 개의 프로세스 간 IPC 통신 기법으로 활용되기도 한다
> - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
> - 범용적인 IPC로서 양방향 통신이 가능하다.
> - 서버 단에서는 bind, listen, accept을 진행하여 소켓 연결을 위한 준비를 하고,
>   클라이언트 단에서는 connect를 통해 서버에 요청하고 연결이 수립된 후, socket에 send함으로써 데이터를 주고 받는다.
