# TCP/IP 흐름제어와 혼잡제어 : 데이터 전송 관리

# 🌟 TCP/IP와 신뢰성

## 1. TCP/IP란?

- 네트워크 통신에서 `신뢰적인 연결방식`
- TCP Buffer : 전송 및 수신 전 TCP 세그먼트를 보관하는 곳
  - 송신 측은 TCP 세그먼트를 보관한 후 순차적으로 전송
  - 수신 측은 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관
- 통신의 신뢰성을 보장하기 위해 흐름 제어 및 혼잡 제어 방식을 사용한다.

## 2. 신뢰성(Reliable Network)를 보장의 4가지 문제점

- (1) 손실 : 패킷이 손실될 수 있는 문제
- (2) 순서 바뀜 : 패킷의 순서가 바뀌는 문제
- (3) Congestion (혼잡) : 네트워크 내 패킷 수가 과도하게 증가하는 현상
- (4) Overload : 수신측이 overload 되는 문제

<br/>

---

<br/>

# 🌟 흐름 제어

## 1. 흐름 제어란?

- **송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위해 사용하는 기법이다.**
- **즉, 수신 측이 너무 많은 패킷을 수신받지 않도록 하는 기법이다.**
- `흐름 제어의 필요성` : 수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다.
  - 송신 측의 속도가 빠를 경우, 수신 측에서 제한한 저장 용량 과정을 초과한 이후에 도착하는 데이터는 손실 될 수 있다.
  - 데이터가 손실 된다면, 불필요한 응답, 데이터 전송이 송/수신 측에 빈번이 발생한다.
    ⇒ 이러한 위험을 줄이기 위해 **송신 측의 데이터 전송량을 수신 측에 따라 조절하는 흐름 제어 기법을 사용**한다.
- `흐름 제어의 기본 원리` : 수신 측이 송신 측에게 자신의 상태를 계속 해서 알리는 것.
  - 데이터를 받을 준비가 되어 있다는 피드백이 이루어졌을 때, 송신 측에서 패킷을 이어 보내도록 하는 것

## 2. 참고) 패킷 전송 과정

TCP/IP 계층에 의해 패킷이 전송되는 과정을 간단히 요약하면 다음과 같다. 다음과 같은 패킷 전송 과정을 살펴보면, 흐름 제어의 필요성을 이해할수 있다.

1. `Application Layer` : 송신측 Application Layer가 소켓에 데이터를 입력한다.
2. `Transport Layer` : 데이터를 세그먼트로 감싸고 Network Layer 에 전달한다.
3. 수신측 노드로 세그먼트가 전송된다. 또한 동시에 송신측의 Send Buffer 와 수신측의 Receive Buffer 각각에 데이터가 저장된다.
4. 수신측 Application Layer 에서 준비가 되면, Receive Buffer 에 있는 데이터를 읽기 시작한다.

⇒ **따라서, Receive Buffer 가 넘쳐나지 않도록 하는 것이 흐름 제어의 핵심이 된다!**

→ 이를 위해 RWND(Receive Window, Receive Buffer 의 남은 공간) 을 송신측에 계속하여 피드백 한다.

## 3. 흐름 제어 기법 종류

### (1) `Stop - And - Wait`

![Untitled (5)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/00b12203-44e3-4976-b72b-9acbd302b71a)

- 매 번 전송한 패킷에 대한 확인 응답(ACK)을 받아야만 그 다음 패킷을 전송하는 기법
- BUT! 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.

### (2) `Sliding Window`

- 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
  - `윈도우(window)`:
    - 윈도우란 메모리 버퍼의 일정 영역으로, 수신 측에서 송신 측으로 ACK를 보낼 때 TCP 헤더(window size)에 담아서 보낸다.
    - 최초의 윈도우 크기는 호스트 들의 3 way handshaking을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다.
- 목적 : 전송은 되었지만, 확인 응답을 받지 못한 byte의 숫자를 파악하기 위해 사용된다.
  - **`LastByteSent - LastByteAcked ≤ ReceiveWindowAvertised`**
    = **마지막에 보낸 바이트 수 - 마지막에 확인된 바이트 수 ≤ 버퍼 남은 공간**
    _= (현재 이도저도 못하고 있는 패킷 수 ≤ 슬라이딩 윈도우 크기)_
- 동작 방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인 되는대로 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송한다.

![Untitled (2)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/b59e4204-acc2-440f-bee5-7da8b8784543)

- 예시) 위 그림에서
- step 1 - 최초로 수신자는 윈도우 사이즈를 7로 정한다
- step 2- 송신자는 수신자의 확인 응답(ACK)를 받기 전까지 데이터를 보낸다
- step 3- 수신자는 확인 응답(ACK)를 송신자에게 보내면, 슬라이딩 윈도우 사이즈를 충족할 수 있게끔 윈도우를 옆으로 옮긴다
  ⇒ 이후 데이터를 다 받을 때까지 위 과정을 반복한다
  <br/>

---

<br/>

# 🌟 혼잡 제어

## 1. 혼잡 제어란?

- **네트워크 내 패킷 수를 제어하여 송신측에서 보내는 데이터의 전송속도를 줄임으로써, 네트워크의 혼잡성 문제를 해결하기 위한 기법**
- 혼잡이란?
  - 네트워크 내에 패킷의 수가 과도하게 증가하는 현상
    → 좀 더 자세히 설명하자면,
  - 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 라우터는 더 이상 데이터를 처리할 수 없다.
  - 이 상황에서 송신 측은 라우터에서 처리하지 못한 데이터를 손실 데이터로 간주하고 계속해서 데이터를 전송하게 된다.
  - 이 경우 혼잡이 가중되어 오버플로우나 데이터 손상을 발생시키게 된다.

## 2. 혼잡 제어 기법

### (1) `AIMD (Additive Increase / Multiplicative Decrease)`

![Untitled (3)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/396285b2-0f76-4df7-9210-434325d85319)

- **처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시켜가며 전송하는 방법.**
  - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
  - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
- 단점:
  - 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸린다.
  - 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다.
    ⇒ 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

### (2) `Slow Start`

![Untitled (4)](https://github.com/do-sopt-cs-study/CS-Yeonseo/assets/77691829/35ee33f1-a37a-4e1f-afc3-23b52967506e)

- AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작해서 **패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window 크기를 지수적(1, 2, 4, 8,,)으로 증가시키다가, 혼잡 현상이 발생하면 window size를 1로 줄이는 방법.**
- 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
- 처음에는 윈도우 크기가 조금 느리게 증가하지만, 시간이 지날수록 윈도우 크기가 빠르게 증가한다.
  ⇒ 전송 속도는 AIMD에 반해 지수 함수 꼴로 증가한다.

### ❗️[패킷을 재전송하는 혼잡제어 기법]

### (3) `Fast Retransmit`

- **패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내는 방식.**
- 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 된다
  - 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다.
    ⇒ 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
    ⇒ 중복된 순번의 패킷을 3개 받으면 재전송을 한다. 이 때, 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
- 장점 : 송신 측에서 자신이 설정한 타임 아웃 시간이 지나지 않았어도 해당 패킷을 재전송할 수 있어 **빠른 재전송률을 유지**할 수 있다.

### (4) `Fast Recovery`

- **혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법.**
- 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

## 3. 혼잡 제어 정책

- 실질적인 혼잡 제어는 이 중 하나만으로 작동하기 보단, 상황에 따라 정책을 바꿔가며 제어한다.
  ex. 처음에는 slow start → 혼잡 상태가 감지되면 AMID
- 혼잡 제어 정책에는 `Tahoe, Reno, New Reno, Cubic, Ealstic-TCP` 등 여러가지가 존재한다.
- 이러한 혼잡 제어 정책들은 공통적으로 **혼잡이 발생하면 윈도우 크기를 줄이거나, 혹은 증가시키지 않으며 혼잡을 회피한다** 라는 전제를 깔고 있다.

<br/>

---

<br/>

# 🌟흐름 제어 vs 혼잡 제어

정리하자면, 흐름 제어와 혼잡 제어의 가장 큰 차이는 다음과 같다.

- `흐름 제어` : **송 수신 측 사이의 패킷 수**를 제어하는 기능
- `혼잡 제어` : **네트워크 내의 패킷 수를** 조절하여 네트워크의 오버플로우를 방지하는 기능
